package app.multiauth.config

import app.multiauth.oauth.OAuthConfig
import app.multiauth.oauth.OAuthProvider
import app.multiauth.util.Logger
import kotlinx.serialization.json.Json
import kotlinx.serialization.encodeToString
import kotlinx.serialization.decodeFromString

/**
 * Manager for OAuth provider configurations.
 * Handles loading and providing OAuth configurations for different providers.
 */
object OAuthConfigurationManager {
    
    private val logger = Logger.getLogger(this::class)
    private val json = Json {
        ignoreUnknownKeys = true
        prettyPrint = true
    }
    
    // In-memory cache of configurations
    private var configuration: OAuthConfiguration? = null
    
    /**
     * Loads OAuth configuration from a JSON string.
     * This is typically called during app initialization with configuration generated by Gradle.
     */
    fun loadConfiguration(configJson: String) {
        try {
            configuration = json.decodeFromString<OAuthConfiguration>(configJson)
            logger.info("config", "OAuth configuration loaded successfully")
            logConfigurationSummary()
        } catch (e: Exception) {
            logger.error("config", "Failed to load OAuth configuration", e)
            configuration = OAuthConfiguration()
        }
    }
    
    /**
     * Loads OAuth configuration from a configuration object.
     */
    fun loadConfiguration(config: OAuthConfiguration) {
        configuration = config
        logger.info("config", "OAuth configuration loaded successfully")
        logConfigurationSummary()
    }
    
    /**
     * Gets the OAuth configuration for a specific provider.
     * 
     * @param provider The OAuth provider
     * @return OAuthConfig for the provider, or null if not configured
     */
    fun getOAuthConfig(provider: OAuthProvider): OAuthConfig? {
        val providerConfig = configuration?.getProvider(provider.name.lowercase())
        return providerConfig?.toOAuthConfig()
    }
    
    /**
     * Gets the OAuth configuration for a specific provider by ID.
     * 
     * @param providerId The provider ID (e.g., "google", "github")
     * @return OAuthConfig for the provider, or null if not configured
     */
    fun getOAuthConfig(providerId: String): OAuthConfig? {
        val providerConfig = configuration?.getProvider(providerId)
        return providerConfig?.toOAuthConfig()
    }
    
    /**
     * Gets the provider configuration for a specific provider.
     * 
     * @param provider The OAuth provider
     * @return OAuthProviderConfiguration for the provider, or null if not configured
     */
    fun getProviderConfiguration(provider: OAuthProvider): OAuthProviderConfiguration? {
        return configuration?.getProvider(provider.name.lowercase())
    }
    
    /**
     * Gets the provider configuration for a specific provider by ID.
     * 
     * @param providerId The provider ID (e.g., "google", "github")
     * @return OAuthProviderConfiguration for the provider, or null if not configured
     */
    fun getProviderConfiguration(providerId: String): OAuthProviderConfiguration? {
        return configuration?.getProvider(providerId)
    }
    
    /**
     * Checks if a provider is configured and enabled.
     * 
     * @param provider The OAuth provider
     * @return true if the provider is configured and enabled
     */
    fun isProviderEnabled(provider: OAuthProvider): Boolean {
        return configuration?.isProviderEnabled(provider.name.lowercase()) == true
    }
    
    /**
     * Checks if a provider is configured and enabled by ID.
     * 
     * @param providerId The provider ID (e.g., "google", "github")
     * @return true if the provider is configured and enabled
     */
    fun isProviderEnabled(providerId: String): Boolean {
        return configuration?.isProviderEnabled(providerId) == true
    }
    
    /**
     * Gets all enabled providers.
     * 
     * @return List of enabled OAuthProviderConfiguration objects
     */
    fun getEnabledProviders(): List<OAuthProviderConfiguration> {
        return configuration?.getEnabledProviders() ?: emptyList()
    }
    
    /**
     * Gets all configured provider IDs.
     * 
     * @return List of configured provider IDs
     */
    fun getConfiguredProviders(): List<String> {
        return configuration?.getConfiguredProviders() ?: emptyList()
    }
    
    /**
     * Gets the current configuration as JSON string.
     * 
     * @return JSON string representation of the configuration
     */
    fun getConfigurationAsJson(): String {
        return configuration?.let { json.encodeToString(it) } ?: "{}"
    }
    
    /**
     * Validates the current configuration.
     * 
     * @return ValidationResult with any issues found
     */
    fun validateConfiguration(): ValidationResult {
        val issues = mutableListOf<String>()
        val config = configuration ?: return ValidationResult(emptyList())
        
        config.providers.forEach { (providerId, providerConfig) ->
            if (providerConfig.clientId.isBlank()) {
                issues.add("Provider '$providerId' has empty client ID")
            }
            
            if (providerConfig.redirectUri.isBlank()) {
                issues.add("Provider '$providerId' has empty redirect URI")
            }
            
            // Validate redirect URI format
            if (providerConfig.redirectUri.isNotBlank()) {
                if (!isValidRedirectUri(providerConfig.redirectUri)) {
                    issues.add("Provider '$providerId' has invalid redirect URI format: ${providerConfig.redirectUri}")
                }
            }
            
            // Validate client secret for providers that require it
            if (providerConfig.clientSecret.isNullOrBlank() && requiresClientSecret(providerId)) {
                issues.add("Provider '$providerId' requires a client secret but none is provided")
            }
        }
        
        return ValidationResult(issues)
    }
    
    /**
     * Clears the current configuration.
     */
    fun clearConfiguration() {
        configuration = null
        logger.info("config", "OAuth configuration cleared")
    }
    
    private fun logConfigurationSummary() {
        val config = configuration ?: return
        val enabledProviders = config.getEnabledProviders()
        
        logger.info("config", "OAuth Configuration Summary:")
        logger.info("config", "  - Total providers configured: ${config.providers.size}")
        logger.info("config", "  - Enabled providers: ${enabledProviders.size}")
        
        enabledProviders.forEach { provider ->
            logger.debug("config", "  - ${provider.providerId}: ${provider.clientId.take(8)}...")
        }
    }
    
    private fun isValidRedirectUri(uri: String): Boolean {
        // Basic validation for common URI schemes
        return uri.startsWith("http://") || 
               uri.startsWith("https://") || 
               uri.matches(Regex("^[a-zA-Z][a-zA-Z0-9+.-]*:.*"))
    }
    
    private fun requiresClientSecret(providerId: String): Boolean {
        // Most OAuth providers require client secrets for security
        // Some exceptions might be mobile apps using PKCE
        return when (providerId.lowercase()) {
            "apple" -> true // Apple requires client secret
            "microsoft" -> true
            "linkedin" -> true
            else -> true // Default to requiring client secret
        }
    }
}

/**
 * Result of configuration validation.
 */
data class ValidationResult(
    val issues: List<String>
) {
    val isValid: Boolean get() = issues.isEmpty()
    val hasIssues: Boolean get() = issues.isNotEmpty()
}
